{"version":3,"sources":["kee_frame/core.cljc"],"mappings":"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","names":["kee-frame.core/kee-frame-interceptors","kee-frame.interceptors/add-global-interceptors","kee-frame.spec/spec-interceptor","kee-frame.state/app-db-spec","kee-frame.debug/debug-interceptor","kee-frame.state/debug?","re-frame.core/trim-v","kee-frame.core/valid-option-key?","kee-frame.core/extra-options","options","cljs.core.filter","p__43222","vec__43223","cljs.core.nth","k","cljs.core/not","cljs.core.into","kee-frame.core/start!","cljs.spec.alpha.valid_QMARK_","expound.alpha.expound","cljs.core.ex_info","cljs.spec.alpha/explain-data","extras","cljs.core/seq","kee-frame.router/start!","kee-frame.core/debug-enabled?","map__43226","cljs.core/deref","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","overwrites?","kee-frame.state/debug-config","and__4115__auto__","kee-frame.core/reg-controller","id","controller","kee-frame.state/controllers","re_frame.core.console","cljs.core.swap_BANG_","cljs.core/assoc","var_args","G__43231","kee-frame.core/reg-event-fx","js/Error","handler","kee_frame.core.reg_event_fx","interceptors","re_frame.core.reg_event_fx","cljs.core.concat","G__43233","kee-frame.core/reg-event-db","kee_frame.core.reg_event_db","re_frame.core.reg_event_db","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","kee-frame.core/reg-chain-named","seq43234","self__4724__auto__","handlers","re-chain.core/reg-chain-named*","kee-frame.core/reg-chain","seq43235","G__43236","cljs.core/first","cljs.core/next","self__4723__auto__","re-chain.core/reg-chain*","kee-frame.core/path-for","seq43237","G__43238","params","kee-frame.router/url","kee-frame.core/switch-route","seq43239","G__43240","f","pairs","kee-frame.router/switch-route"],"sourcesContent":["(ns kee-frame.core\n  (:require [kee-frame.state :as state]\n            [kee-frame.router :as router]\n            [re-chain.core :as chain]\n            [re-frame.core :as rf :refer [console]]\n            [kee-frame.spec :as spec :refer [spec-interceptor]]\n            [kee-frame.debug :refer [debug-interceptor]]\n            [kee-frame.interceptors :as i]\n            [clojure.spec.alpha :as s]\n            [expound.alpha :as e]))\n\n;; Interceptors used by all chains and events registered through kee-frame\n(def kee-frame-interceptors [i/add-global-interceptors (spec-interceptor state/app-db-spec) (debug-interceptor state/debug?) rf/trim-v])\n\n(def valid-option-key? #{:router :hash-routing? :routes :process-route :debug? :debug-config\n                         :chain-links :app-db-spec :root-component :initial-db\n                         :screen :scroll :route-change-event :not-found})\n\n(defn extra-options\n  \"Complete listing of invalid options sent to the `start!` function.\"\n  [options]\n  (->> options\n       (filter (fn [[k]] (not (valid-option-key? k))))\n       (into {})))\n\n(defn start!\n  \"Starts your client application with the specified `options`.\n\n  This function is intentionally forgiving in certain ways:\n  - You can call it as often as you want. Figwheel should call it on each code change\n  - You can omit the `options` altogether. kee-frame chooses sensible defaults for you and leads the way.\n\n  Usage:\n  ```\n  (k/start! {:debug?         true\n             :routes         my-reitit-routes\n             :hash-routing?  true\n             :initial-db     {:some-property \\\"default value\\\"}\n             :root-component [my-reagent-root-component]\n             :app-db-spec    :spec/my-db-spec})\n  ```\"\n  [options]\n  (when-not (s/valid? ::spec/start-options options)\n    (e/expound ::spec/start-options options)\n    (throw (ex-info \"Invalid options\" (s/explain-data ::spec/start-options options))))\n  (let [extras (extra-options options)]\n    (when (seq extras)\n      (throw (ex-info (str \"Uknown startup options. Valid keys are \" valid-option-key?) extras))))\n  (router/start! options))\n\n(defn debug-enabled? []\n  (let [{:keys [overwrites?]\n         :or   {overwrites? false}} @state/debug-config]\n    (and @state/debug?\n         overwrites?)))\n\n(defn reg-controller\n  \"Put a controller config map into the global controller registry.\n\n  Parameters:\n\n  `id`: Must be unique in controllere registry. Will appear in logs.\n\n  `controller`: A map with the following keys:\n  - `:params`: A function that receives the route data and returns the part that should be sent to the `start` function. A nil\n  return means that the controller should not run for this route.\n\n  - `:start`: A function or an event vector. Called when `params` returns a non-nil value different from the previous\n  invocation. The function receives whatever non-nil value that was returned from `params`,\n  and returns a re-frame event vector. If the function does nothing but returning the vector, the surrounding function\n  can be omitted.\n\n  - `:stop`: Optional. A function or an event vector. Called when previous invocation of `params` returned non-nil and the\n  current invocation returned nil. If the function does nothing but returning the vector, the surrounding function\n  can be omitted.\"\n  [id controller]\n  (when-not (s/valid? ::spec/controller controller)\n    (e/expound ::spec/controller controller)\n    (throw (ex-info \"Invalid controller\" (s/explain-data ::spec/controller controller))))\n  (when (and (debug-enabled?)\n             (get @state/controllers id))\n    (console :warn \"Overwriting controller with id \" id))\n  (swap! state/controllers assoc id controller))\n\n(defn reg-event-fx\n  \"Exactly same signature as `re-frame.core/reg-event-fx`. Use this version if you want kee-frame logging and spec validation.\n\n  `re-frame.core/trim-v` interceptor is also applied.\"\n  ([id handler] (reg-event-fx id nil handler))\n  ([id interceptors handler] (rf/reg-event-fx id (concat kee-frame-interceptors interceptors) handler)))\n\n(defn reg-event-db\n  \"Exactly same signature as `re-frame.core/reg-event-db`. Use this version if you want kee-frame logging and spec validation.\n\n  `re-frame.core/trim-v` interceptor is also applied.\"\n  ([id handler] (reg-event-db id nil handler))\n  ([id interceptors handler] (rf/reg-event-db id (concat kee-frame-interceptors interceptors) handler)))\n\n(defn reg-chain-named\n  \"Same as `reg-chain`, but with manually named event handlers. Useful when you need more meaningful names in your\n  event log.\n\n  Parameters:\n\n  `handlers`: pairs of id and event handler.\n\n  Usage:\n  ```\n  (k/reg-chain-named\n\n    :load-customer-data\n    (fn [ctx [customer-id]]\n      {:http-xhrio {:uri \\\"...\\\"}})\n\n    :receive-customer-data\n     (fn [ctx [customer-id customer-data]]\n      (assoc-in ctx [:db :customers customer-id] customer-data)))\n  ```\"\n  [& handlers]\n  (apply chain/reg-chain-named* kee-frame-interceptors handlers))\n\n(defn reg-chain\n  \"Register a list of re-frame fx handlers, chained together.\n\n  The chaining is done through dispatch inference. https://github.com/Day8/re-frame-http-fx is supported by default,\n  you can easily add your own like this: https://github.com/ingesolvoll/kee-frame#configuring-chains-since-020.\n\n  Each handler's event vector is prepended with accumulated event vectors of previous handlers. So if the first handler\n  receives [a b], and the second handler normally would receive [c], it will actually receive [a b c]. The purpose is\n  to make all context available to the entire chain, without a complex framework or crazy scope tricks.\n\n  Parameters:\n\n  `id`: the id of the first re-frame event. The next events in the chain will get the same id followed by an index, so\n  if your id is `add-todo`, the next one in chain will be called `add-todo-1`.\n\n  `handlers`: re-frame event handler functions, registered with `kee-frame.core/reg-event-fx`.\n\n\n  Usage:\n  ```\n  (k/reg-chain\n    :load-customer-data\n\n    (fn [ctx [customer-id]]\n      {:http-xhrio {:uri    (str \\\"/customer/\\\" customer-id)\n                    :method :get}})\n\n    (fn [cxt [customer-id customer-data]\n      (assoc-in ctx [:db :customers customer-id] customer-data)))\n  ```\"\n  [id & handlers]\n  (apply chain/reg-chain* id kee-frame-interceptors handlers))\n\n(defn path-for\n  \"Make a uri from route data. Useful for avoiding hard coded links in your app.\n\n  Parameters:\n\n  `handler`: The reitit handler from route data\n\n  `params`: Reitit route params for the requested route\n\n  Usage: `[:a {:href (k/path-for [:orders :sort-by :date]} \\\"Orders sorted by date\\\"]`\"\n  [handler & params]\n  (apply router/url handler params))\n\n(defn switch-route\n  \"Reagent component that renders different components for different routes.\n\n  You might need to include a case for `nil`, since there are no route data before the first navigation.\n\n  Parameters:\n\n  `f`: A function that receives the route data on every route change, and returns the value to dispatch on.\n\n  `pairs`: A pair consists of the dispatch value and the reagent component to dispatch to.\n\n  Returns the first component with a matching dispatch value.\n\n  Usage:\n  ```\n  [k/switch-route (fn [route] (:handler route))\n    :index [:div \\\"This is index page\\\"]\n    :about [:div \\\"This is the about page\\\"]\n    nil    [:div \\\"Probably also the index page\\\"]]\n  ```\"\n  [f & pairs]\n  (apply router/switch-route f pairs))\n"]}