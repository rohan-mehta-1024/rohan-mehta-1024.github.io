goog.provide('personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation');
personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.post_preview = "Automatic differentiation is the numerical computing technique\n   that gave us the backpropogation algorithm, which is\n   how neural nets learn. In this post, we will explore\n   the mathematics behind it \u2013 both in the context of neural nets\n   and more broadly.";
personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.post_content = new cljs.core.PersistentVector(null, 24, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"div","div",1057191632),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"Backpropogation is the cornerstone of the differentiable\n        programming paradigm \u2014 the idea that we can allow programs to optimize\n        their behavior against certain metrics by  differentiating over and updating sets\n        of learnable functions. In fact, it is the very algorithm that allows neural\n        nets to learn! Less talked about is automatic differentiation, the numerical computing technique\n        that makes it possible, and one of the key reasons\n        neural nets are able to transcend theory and work in real life."], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"Both, however, are essential to a thorough understanding of\n        how and why neural nets are even possible in the first place.\n        In this post, we'll go through the mathematics underpinning both\n        of them, which is a journey far less restricted to the realm\n        of a calculus than you may expect (no spoilers!).\n        That said, there is no escaping the calculus, so if you feel it's\n        worth taking a few moments\n        to review how exactly we take the deriavatives of multivariate functions, continue on.\n        Otherwise, skip here.\n        "], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"h1","h1",-1896887462),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"class","class",-2030961996),"post-section-header"], null),"Learning To Differentiate"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"Derivatives of single-variable functions are\n        measurements of how infinitesimal variations to a function's\n        input-space correspond to variations in the output-space. And the same\n        is true of multivariable functions,\n        except now we have many more ways in which\n        we can vary our input-space."], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"To start though, let\u2019s consider the case of a\n        function of two variables. Such a function can be pictured as a surface\n        above the Cartesian plane, where the height of a point\n        on that surface is calculated using the function\n        \\(f(x,y)\\) in question. With this in mind, the geometrical\n        interpretation of the derivative is how the elevation of\n        this surface changes given a small step in some direction."], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"figure","figure",-561394079),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"class","class",-2030961996),"img-container"], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"div","div",1057191632),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"text-align","text-align",1786091845),"center"], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"img","img",1442687358),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"src","src",-1651076051),"/multi-fn-2.png",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"width","width",-384071477),"45%"], null)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"img","img",1442687358),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"src","src",-1651076051),"/multi-fn-4.png",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"width","width",-384071477),"45%"], null)], null)], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"figcaption","figcaption",-1790122047),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"class","class",-2030961996),"post-caption",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"text-align","text-align",1786091845),"left"], null)], null),"Fig. 2. Examples of surfaces that can be generated\n     by a function of two variables (Source: ",personal_website.utils.link("CalcPlot3D","https://www.monroecc.edu/faculty/paulseeburger/calcnsf/CalcPlot3D/"),")."], null)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"An important thing to notice here is that this step could be in any direction:\n        vertical, horizontal, or some combination of the two (diagonal). For simplicity\n        though, we'll resitrict ourselves to the first two cases\u00A0\u2013 those in which we take\n        steps in purely the \\(x\\) and \\(y\\) directions \u2013 for right now.\n        So how would we calculate the derivative of the function \\(f(x,y) = x^2 + y^2\\)\n        with respect to \\(x\\) then?"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"Imagine standing at some point on this function's surface, and walking\n        horizontally in both directions. If we walk such that a spool of\n        yarn unrolls behind  us, the shape this yarn takes will\n        resemble the graph of a single-variate function.\n        More specifically, it will look like\n          \\(f(x) = x^2 + C\\) (a parabola) where \\(C\\) is some constant, namely\n        whatever the \\(y\\)-value of our original point was."], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"It might not be immediately obvious, but by walking horizontally\n        across our surface we only varied our \\(x\\)-coordinate, while\n        our \\(y\\)-coordinate remained constant.\n        Thus, when walking in this way,\n        the surface can be described\n        by a special case of the original function where\n        \\(y\\) is a constant."], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"Similarly, a walk\n           in a purely vertical direction is described\n           when \\(x\\) is a constant. More generally, we would find that\n           all multivariate functions\n           behave in this way when being sliced\n           (or walked upon) purely in the direction of one their variables, such\n           that all others become constants."], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"figure","figure",-561394079),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"class","class",-2030961996),"img-container"], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"div","div",1057191632),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"text-align","text-align",1786091845),"center"], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"img","img",1442687358),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"src","src",-1651076051),"/parabaloid-1.png",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"width","width",-384071477),"50%"], null)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"img","img",1442687358),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"src","src",-1651076051),"/parabaloid-2.png",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"width","width",-384071477),"50%"], null)], null)], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"figcaption","figcaption",-1790122047),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"class","class",-2030961996),"post-caption",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"text-align","text-align",1786091845),"left"], null)], null),"Fig. 3. The graph the function \\(f(x,y) = x^2 + y^2\\), known as a parabaloid.\n    Slicing it across the \\(x\\)-axis reveals that \\(x\\)-wise\n    cross-sections are parabolas. In fact, this property defines the surface! (Source: ",personal_website.utils.link("GeoGebra3D","https://www.geogebra.org/3d?lang=en"),")."], null)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"In that vein of thought, we might conjecture that when computing\n        the derivative of our function \\(f(x,y) = x^2 + y^2\\) with\n        respect to \\(x\\), we can imagine we are taking the\n        derivative of \\(f(x) = x^2 + C\\), as this is what\n        the surface looks like when moving in the \\(x\\) direction.\n        Then the deriavative with respect to \\(x\\)\n        (what we call its partial derivative)\n        would be \\(2x\\). That is to say\n        \\(\\frac{\\partial{f}}{\\partial{x}}\\ = 2x\\)\n        (as would \\(\\frac{\\partial{f}}{\\partial{y}}\\))."], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"And it turns out that this thought is in fact correct!",personal_website.utils.make_footnote("1","first-footnote-a","first-footnote-b")," But how do we generalize this idea when taking steps across our surface that aren't\n          purely horizontal or vertical in nature? For instance,\n          what is the derivative associated with some step in the\n        direction of the vector \\(\\langle 1, 1 \\rangle \\)?"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"\n        Well, a step in this direction is equivelant to one step\n        in both the \\(x\\) direction and \\(y\\) direction.\n        And since we know how our function changes for both a pure step in the\n        \\(x\\) direction (\\(\\frac{\\partial{f}}{\\partial{x}}\\)) and \\(y\\)\n        direction (\\(\\frac{\\partial{f}}{\\partial{y}}\\)), the derivative\n        in this direction is just a sum of the two: \\(\\frac{\\partial{f}}{\\partial{x}} + \\frac{\\partial{f}}{\\partial{y}}\\ =\n        2x + 2y\\)."], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"More generally, given any multivariate function of \\(n\\) variables,\n       we can express a derivative with respect to some vector \u2013 what we\n       call a directional derivative \u2013 as the linear combination of that function's partial derivatives\n       and the components of that vector. Said another way, given the vectors:"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"$$ \\boldsymbol{\\vec{\\alpha}} = \\begin{bmatrix}\n          a_{1} \\\\\n          a_{2} \\\\\n          \\vdots \\\\\n          a_{n} \\\\\n          \\end{bmatrix}\n          \\hspace{1cm}\n          \\boldsymbol{\\vec{\\beta}} =\n          \\begin{bmatrix}\n          \\frac{\\partial{f}}{\\partial{x_1}} \\\\\n          \\frac{\\partial{f}}{\\partial{x_2}} \\\\\n          \\vdots \\\\\n          \\frac{\\partial{f}}{\\partial{x_n}} \\\\\n          \\end{bmatrix}\n        $$"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"margin-bottom","margin-bottom",388334941),"25px"], null)], null),"Then the derivative of \\(f(x_1, x_2, \\ldots, x_n)\\) with respect to \\(\\boldsymbol{\\vec{\\alpha}}\\) is \\(\\boldsymbol{\\vec{\\alpha}} \\cdot \\boldsymbol{\\vec{\\beta}}\\).\n        Just as before, the given vector can be decomposed as the sum of steps in the direction\n        of a single variable (\\(a_1\\hat{\\imath} + a_2\\hspace{0.08cm}\\skew{2}{\\hat}{\\jmath} + \\ldots\\)),\n        and as a function's partials represent the effects of such steps,\n        the derivative in this direction is just their sum,\n        one for each step taken in the direction they represent (\\(a_1 \\frac{\\partial{f}}{\\partial{x_1}} + a_2 \\frac{\\partial{f}}{\\partial{x_2}} + \\ldots \\))."], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"figure","figure",-561394079),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"class","class",-2030961996),"img-container"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"img","img",1442687358),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"src","src",-1651076051),"/parabaloid-5.png",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"width","width",-384071477),"50%"], null)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"img","img",1442687358),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"src","src",-1651076051),"/parabaloid-6.png",new cljs.core.Keyword(null,"style","style",-496642736),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"width","width",-384071477),"50%"], null)], null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"figcaption","figcaption",-1790122047),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"class","class",-2030961996),"post-caption"], null),"Fig. 4. The slice of the parabaloid in the direction\n   \\(\\langle 1, 1 \\rangle\\) is also a parabola, albeit a\n   steeper one. It's generating function is \\(2n^2\\) for every \\(n\\) steps along this vector (see\n   right image where an \\(n = 1\\) returns \\(2\\))."], null)], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"While this isn't rigorous"," (how can you take multiple infinitesimal steps?),",personal_website.utils.make_footnote("2","second-footnote-a","second-footnote-b"),"\n        it suits our immediate purposes, as we can now calculate both partial\n        and directional derivatives. A natural question then, is what derivative is the greatest?\n        In what direction does a function increase most rapidly?"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"In other words, what vector, when dotted with the vector containing\n        the partials of our function, yields the largest possible\n        value? Well, the largest dot product a vector can have (when only\n        considering vectors of the same magnitude) is with\n        itself, so the direction of steepest ascent must be represented by the thing\n        we're dotting against \u2013\u00A0the vector containing the partials of our function! "], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"Intuitively, this makes sense too, as how much this vector points in a given\n        direction is equivelant to the derivative in that direction, such that it points\n        more in steeper directions and less in shallow ones, thus becoming the steepest direction itself.",personal_website.utils.make_footnote("3","third-footnote-a","third-footnote-b"),"\n        It is yielded by the \\(\\nabla\\) \u2013 or gradient \u2013 operation:"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"p","p",151049309),"$$\\nabla f(x_1, x_2, \\ldots, x_n) =\n          \\begin{bmatrix}\n          \\frac{\\partial{f}}{\\partial{x_1}} \\\\\n          \\frac{\\partial{f}}{\\partial{x_2}} \\\\\n          \\vdots \\\\\n          \\frac{\\partial{f}}{\\partial{x_n}} \\\\\n          \\end{bmatrix}$$"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,"h1","h1",-1896887462),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"class","class",-2030961996),"post-section-header"], null),"Gradient Descent"], null)], null);
personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.media_query_1 = (function personal_website$content$writings$blog_posts$the_mathematics_of_automatic_differentiation$media_query_1(){
return garden.stylesheet.at_media.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,"max-width","max-width",-1939924051),"600px"], null),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.PersistentVector.EMPTY], 0));
});
personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.post = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,"tags","tags",1771418977),new cljs.core.Keyword(null,"overarching","overarching",696949346),new cljs.core.Keyword(null,"date","date",-1463434462),new cljs.core.Keyword(null,"content","content",15833224),new cljs.core.Keyword(null,"css","css",1135045163),new cljs.core.Keyword(null,"type","type",1174270348),new cljs.core.Keyword(null,"title","title",636505583),new cljs.core.Keyword(null,"id","id",-1388402092),new cljs.core.Keyword(null,"show","show",-576705889)],[new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, ["mathematics","deep learning"], null),"writing","2020/10/29",personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.post_content,personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.media_query_1(),"blog-post","The Mathematics Of Automatic Differentiation","1",personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.post_preview]);

//# sourceMappingURL=personal_website.content.writings.blog_posts.the_mathematics_of_automatic_differentiation.js.map
